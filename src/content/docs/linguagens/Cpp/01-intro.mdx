---
title: Introdu√ß√£o ao C++
sidebar:
  order: 1
slug: cpp-intro
---

Boa pessoal, vamos come√ßar a programar em C++!üíª 
O foco √© construir uma **base computacional**: entender o que √© um programa, como ele √© executado e como escrever os primeiros c√≥digos. N√£o vamos nos preocupar com desempenho ou recursos avan√ßados ‚Äî apenas com o in√≠cio da programa√ß√£o.

C++ √© uma **linguagem compilada**, onde o c√≥digo que voc√™ escreve (arquivo fonte) √© transformado por um **compilador** em um programa execut√°vel que o sistema operacional roda. Esse processo de compila√ß√£o acontece antes da execu√ß√£o; depois de compilar, voc√™ roda o execut√°vel. 

> "Calma l√° Muril√£o, mas qual o significado disso?"

Boa pergunta, quando trabalhamos com uma linguagem compilada, temos algumas diferen√ßas que devemos ter em mente. A primeira delas, √© que o que estamos escrevendo n√£o pode ser executado diretamente pelo sistema operacional. Ou seja, as instru√ß√£o do nosso programa n√£o podem ser interpretadas pelo computador diretamente. O que significa, que precisamos de algum elemento que consiga traduzir nossos c√≥digos para uma linguagem que o computador consiga entender para executar eles. Ai que entre o compilador. 

A sua fun√ß√£o √© transformar nosso programa em um conjunto de dados bin√°rios que o processador consiga interpretar e executar. Os compiladores surgiram nos anos 1950, quando se passou a escrever programas em linguagens de n√≠vel mais alto  em vez de s√≥ em linguagem de m√°quina ou assembly. Um marco √© o compilador de Fortran (1957), desenvolvido na IBM sob a lideran√ßa de John Backus, que traduzia programas em Fortran para c√≥digo de m√°quina. Nessa mesma √©poca, Grace Hopper e sua equipe trabalhavam em tradutores autom√°ticos (como o A-0), que deram base √†s ideias de compila√ß√£o. A fun√ß√£o de um compilador √© ler o c√≥digo fonte escrito em uma linguagem (por exemplo C++) e gerar um programa equivalente em uma linguagem que o hardware ‚Äî ou uma m√°quina virtual ‚Äî consiga executar (em geral c√≥digo de m√°quina ou bytecode). Assim, o compilador faz a ponte entre a linguagem que o programador usa e a linguagem que a m√°quina executa, permitindo que o mesmo c√≥digo seja reutilizado em diferentes m√°quinas e que erros de sintaxe e parte dos erros de uso da linguagem sejam detectados antes da execu√ß√£o.

Com isso em mente, vamos direto ao uso.

## 1. O que voc√™ precisa

Para programar em C++, voc√™ precisa de:

- **Compilador:** um programa que l√™ seu c√≥digo e gera o execut√°vel. Exemplos: [GCC](https://gcc.gnu.org/) (comando `g++`), [Clang](https://clang.llvm.org/) (`clang++`) ou, no Windows, [Visual Studio](https://visualstudio.microsoft.com/) (MSVC) ou [MinGW](https://www.mingw-w64.org/).
- **Editor de texto ou IDE:** onde voc√™ escreve o c√≥digo. Qualquer editor serve; uma IDE facilita compilar e rodar com um clique.

:::tip[Verificando o compilador]
No terminal, digite `g++ --version` ou `clang++ --version`. Se aparecer a vers√£o, o compilador est√° instalado e no PATH.
:::

:::danger[Recomenda√ß√£o para iniciantes]

Pessoal, aqui deixo uma recomenda√ß√£o, em especial para quem est√° iniciando no desenvolvimento ou come√ßando agora a trabalhar com esse tipo de ferramentas: procurem utilizar IDE, ambientes integrados de desenvolvimento. Qual a principal diferen√ßa: eles, muitas vezes, v√£o trazer os compiladores junto do editor sem grandes problemas para o usu√°rio.

Assim, o foco fica no desenvolvimento e n√£o na configura√ß√£o do ambiente. N√£o entenda mal, essa etapa √© importante, mas no momento incorreto, pode trazer uma sobrecarga cognitiva que vai atralhar o seu desenvolvimento.

Dito isso, minha recomenda√ß√£o:

- *Windows:* [Code Blocks](https://sourceforge.net/projects/codeblocks/files/Binaries/25.03/Windows/codeblocks-25.03mingw-setup.exe)
- *Linux:* [Code Blocks](https://www.codeblocks.org/downloads/binaries/) - verificar a vers√£o do seu sistema operacional
- *MacOS:* Xcode

:::

## 2. O primeiro programa

Todo programa C++ execut√°vel precisa de uma fun√ß√£o chamada `main`: √© por ela que a execu√ß√£o come√ßa. Um exemplo m√≠nimo que s√≥ imprime uma mensagem √©:

```cpp
#include <iostream>

int main() {
    std::cout << "Ol√°, mundo!" << std::endl;
    return 0;
}
```

O que aparece a√≠:

- **`#include <iostream>`** ‚Äî inclui a parte da biblioteca padr√£o que permite entrada e sa√≠da (ler do teclado e imprimir na tela).
- **`int main()`** ‚Äî define a fun√ß√£o principal; o programa come√ßa aqui.
- **`std::cout << ...`** ‚Äî envia o que est√° √† direita para a sa√≠da padr√£o (o terminal). `std::endl` pula uma linha.
- **`return 0;`** ‚Äî indica que o programa terminou sem erro (conven√ß√£o para o sistema operacional).

Salve o c√≥digo em um arquivo, por exemplo `ola.cpp`. No terminal, na pasta do arquivo:

```bash
g++ -o ola ola.cpp
./ola
```

(O primeiro comando gera o execut√°vel `ola`; o segundo roda. No Windows, use `ola.exe` ou apenas `ola` dependendo do ambiente.)


Em C++, a biblioteca padr√£o (entrada/sa√≠da, strings, containers, etc.) fica no *namespace std*. O prefixo *std::* indica que o nome que vem em seguida pertence a esse namespace ‚Äî por exemplo, `std::cout` √© o cout da biblioteca padr√£o. Isso evita conflito com outros nomes: se voc√™ criar uma vari√°vel ou fun√ß√£o chamada cout no seu c√≥digo, ela n√£o se mistura com o cout da biblioteca, que continua sendo std::cout. Usar std:: deixa expl√≠cito que voc√™ est√° usando recursos da biblioteca padr√£o e √© uma pr√°tica comum em material did√°tico e em projetos que preferem clareza √† economia de digita√ß√£o.

Para n√£o precisar escrever std:: toda vez, podemos usar a diretiva using. Com using namespace std;, todos os nomes do namespace std passam a ser usados sem prefixo no arquivo (ou no bloco) em que a diretiva aparece. Outra op√ß√£o √© ser mais seletivo: using std::cout; e using std::cin; trazem s√≥ cout e cin para o escopo, reduzindo o risco de conflitos. Em c√≥digos pequenos ou em material introdut√≥rio isso deixa o programa mais curto e leg√≠vel; em projetos maiores costuma-se evitar using namespace std no topo do arquivo para n√£o ‚Äúpoluir‚Äù o escopo com todos os nomes da biblioteca padr√£o.

## Vari√°veis e Tipos Primitivos

C++ √© uma linguagem fortemente tipada. As vari√°veis devem ser declaradas com um
tipo espec√≠fico.
```cpp
#include <iostream>

int main() {
    int idade = 25;           // Inteiro
    double altura = 1.75;     // Ponto flutuante (precis√£o dupla)
    char letra = 'A';         // Caractere √∫nico
    bool programador = true;  // Booleano (true/false)
    
    // std::string requer #include <string>, mas √© fundamental conhecer
    // (Veremos mais em STL)
    
    std::cout << "Idade: " << idade << std::endl;
    std::cout << "Altura: " << altura << std::endl;
    
    return 0;
}
```

### Infer√™ncia de Tipo (`auto`)

A partir do C++11, a palavra-chave `auto` permite que o compilador deduza o
tipo da vari√°vel com base no valor de inicializa√ß√£o. Isso √© √∫til para reduzir a
verbosidade, especialmente com tipos complexos.

```cpp
auto x = 10;        // Deduzido como int
auto y = 3.14;      // Deduzido como double
auto z = "Texto";   // Deduzido como const char*

// O tipo √© fixo ap√≥s a dedu√ß√£o. N√£o √© tipagem din√¢mica!
// x = "Erro"; // Isso causaria erro de compila√ß√£o
```

## Entrada e Sa√≠da

A biblioteca `<iostream>` fornece `std::cin` para entrada e `std::cout` para
sa√≠da.

```cpp
#include <iostream>

int main() {
    int numero;
    
    std::cout << "Digite um n√∫mero: ";
    std::cin >> numero; // L√™ o input do usu√°rio e armazena em 'numero'
    
    std::cout << "Voc√™ digitou: " << numero << std::endl;
    
    return 0;
}
```

:::tip[namespace]

Um namespace em C++ √© um mecanismo que agrupa nomes (vari√°veis, fun√ß√µes, classes, etc.) dentro de um ‚Äúespa√ßo de nomes‚Äù. Assim, o mesmo identificador pode existir em namespaces diferentes sem conflito: por exemplo, std::cout e um cout definido em outro namespace s√£o coisas distintas. O compilador usa o namespace para saber exatamente qual entidade voc√™ est√° referenciando. A biblioteca padr√£o do C++ coloca seus recursos no namespace std; por isso usamos std::cout, std::cin, etc. Namespaces ajudam a organizar c√≥digo grande, a evitar colis√µes de nomes entre bibliotecas e a deixar expl√≠cita a origem de cada nome.

Voc√™ usa um nome de um namespace de duas formas: com o nome qualificado (ex.: std::cout) ou trazendo o nome para o escopo atual com using (ex.: using std::cout; ou using namespace std;). Definir um namespace seu √© feito com a palavra-chave namespace seguida do nome e de um bloco { } com as declara√ß√µes. Em resumo: namespace √© o ‚Äúsobrenome‚Äù que desambigua e organiza os nomes no C++.

Mas calma! Vamos retomar esse conceito quando avan√ßarmos mais com a linguagem!

:::

## 3. Vari√°veis e tipos b√°sicos

Um programa trabalha com **dados** armazenados em **vari√°veis**. Em C++ voc√™ declara o **tipo** da vari√°vel e, se quiser, j√° d√° um valor a ela.

Alguns tipos b√°sicos:

| Tipo     | Descri√ß√£o breve              | Exemplo de valor |
|----------|------------------------------|------------------|
| `int`    | N√∫meros inteiros             | `42`, `-7`       |
| `double` | N√∫meros reais (ponto flutuante) | `3.14`, `-0.5` |
| `char`   | Um caractere                 | `'A'`, `'9'`     |
| `bool`   | Verdadeiro ou falso          | `true`, `false`  |

Exemplo de declara√ß√£o e uso:
=======
## Estruturas de Controle

As estruturas de controle em C++ s√£o muito semelhantes √†s de C, Java e C#.

### Condicionais

```cpp
int x = 10;

if (x > 0) {
    std::cout << "Positivo";
} else if (x < 0) {
    std::cout << "Negativo";
} else {
    std::cout << "Zero";
}
```

### La√ßos de Repeti√ß√£o

```cpp
// Loop For
for (int i = 0; i < 5; i++) {
    std::cout << i << " ";
}
// Sa√≠da: 0 1 2 3 4

// Loop While
int contador = 0;
while (contador < 3) {
    std::cout << "Contando: " << contador << "\n";
    contador++;
}
```

## Fun√ß√µes

```cpp
#include <iostream>

using namespace std;

int main() {
    int a, b;
    cout << "Digite dois n√∫meros: ";
    cin >> a >> b;

    int soma = a + b;
    cout << "Soma: " << soma << endl;

    return 0;
}
```

- **`cin >> a >> b`** ‚Äî l√™ dois valores do teclado e armazena em `a` e `b` (separados por espa√ßo ou Enter).
- **`int soma = a + b`** ‚Äî calcula a soma e guarda em uma nova vari√°vel.

Esse √© o padr√£o b√°sico: declarar vari√°veis, ler com `cin`, fazer c√°lculos e mostrar resultados com `cout`.

Resumo do fluxo: escrever, compilar, executar:

1. **Escrever** o c√≥digo em um arquivo (por exemplo `.cpp`).
2. **Compilar** com o compilador (ex.: `g++ -o meu_programa meu_programa.cpp`).
3. **Executar** o programa gerado (ex.: `./meu_programa` no Linux/macOS ou `meu_programa.exe` no Windows).

Se houver erro de sintaxe, o compilador mostra mensagens na linha em que detectou o problema. Corrija o c√≥digo e compile de novo.

// Declara√ß√£o da fun√ß√£o (prot√≥tipo)
int somar(int a, int b);

int main() {
    int resultado = somar(5, 3);
    std::cout << "A soma √©: " << resultado << std::endl;
    return 0;
}

// Defini√ß√£o da fun√ß√£o
int somar(int a, int b) {
    return a + b;
}
```
