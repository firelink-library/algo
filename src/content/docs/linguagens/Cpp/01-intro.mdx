---
title: Introdu√ß√£o ao C++
sidebar:
  order: 1
slug: cpp-intro
---

## Vamos come√ßar a programar em C++! üíª

O foco √© construir uma **base computacional**: entender o que √© um programa,
como ele √© executado e como escrever os primeiros c√≥digos. N√£o vamos nos
preocupar com desempenho ou recursos avan√ßados, apenas com o in√≠cio da
programa√ß√£o.

C++ √© uma **linguagem compilada**, onde o c√≥digo que voc√™ escreve (arquivo
fonte) √© transformado por um **compilador** em um programa execut√°vel que o
sistema operacional roda. Esse processo de compila√ß√£o acontece antes da
execu√ß√£o; depois de compilar, voc√™ roda o execut√°vel.

## Mas o que isso significa?

Quando trabalhamos com uma linguagem compilada, temos algumas diferen√ßas que
devemos ter em mente. A primeira delas √© que o c√≥digo que escrevemos n√£o pode
ser executado diretamente pelo sistema operacional. As instru√ß√µes do nosso
programa n√£o s√£o interpretadas pelo computador diretamente. Precisamos de um
elemento que traduza nossos c√≥digos para uma linguagem que o computador consiga
entender e executar. √â a√≠ que entra o compilador. 

A fun√ß√£o do compilador √© transformar nosso programa em um conjunto de dados
bin√°rios que o processador consiga interpretar e executar. Os compiladores
surgiram nos anos 1950, quando se passou a escrever programas em linguagens de
n√≠vel mais alto em vez de apenas em linguagem de m√°quina ou assembly. Um marco
importante foi o compilador de Fortran (1957), desenvolvido na IBM sob a
lideran√ßa de John Backus. Nessa mesma √©poca, Grace Hopper e sua equipe
trabalhavam em tradutores autom√°ticos (como o A-0), que deram base √†s ideias de
compila√ß√£o.

O compilador l√™ o c√≥digo fonte escrito em uma linguagem (como C++) e gera um
programa equivalente em uma linguagem que o hardware consiga executar (geralmente c√≥digo de m√°quina ou bytecode). Dessa forma, o compilador faz a ponte entre a linguagem que o programador usa e a linguagem que a m√°quina executa, permitindo que o mesmo c√≥digo seja reutilizado em diferentes m√°quinas e que erros de sintaxe sejam detectados antes da execu√ß√£o.

Com isso em mente, vamos direto ao uso.

## O que voc√™ precisa

Para programar em C++, voc√™ precisa de:

- **Compilador:** um programa que l√™ seu c√≥digo e gera o execut√°vel. Exemplos:
  [GCC](https://gcc.gnu.org/) (comando `g++`),
  [Clang](https://clang.llvm.org/) (`clang++`) ou, no Windows,
  [Visual Studio](https://visualstudio.microsoft.com/) (MSVC) ou
  [MinGW](https://www.mingw-w64.org/).
- **Editor de texto ou IDE:** onde voc√™ escreve o c√≥digo. Qualquer editor
  serve; uma IDE facilita compilar e rodar com um clique.

:::tip[Verificando o compilador]
No terminal, digite `g++ --version` ou `clang++ --version`. Se aparecer a
vers√£o, o compilador est√° instalado e no PATH.
:::

:::danger[Recomenda√ß√£o para iniciantes]

Uma recomenda√ß√£o especial para quem est√° iniciando no desenvolvimento: procure
utilizar uma IDE (Ambiente Integrado de Desenvolvimento). A principal
vantagem √© que elas geralmente trazem os compiladores integrados, facilitando
a configura√ß√£o.

Assim, o foco fica no desenvolvimento e n√£o na configura√ß√£o do ambiente. Essa
etapa de configura√ß√£o √© importante, mas no momento incorreto pode trazer uma
sobrecarga cognitiva que atrapalha o aprendizado.

Recomenda√ß√µes por sistema operacional:

- *Windows:* [Code Blocks][cb-win]
- *Linux:* [Code Blocks][cb-linux] - verificar a
  vers√£o do seu sistema operacional
- *MacOS:* Xcode

[cb-win]: https://sourceforge.net/projects/codeblocks/files/Binaries/25.03/Windows/codeblocks-25.03mingw-setup.exe
[cb-linux]: https://www.codeblocks.org/downloads/binaries/

:::

> ` Calma l√°! Voc√™s n√£o falaram para usar o Visual Studio? `

Boa coloca√ß√£o, o Visual Studio √© uma √≥tima e poderosa ferramenta. Contudo, ela tem um curva de aprendizado um pouco maior, quando comparada com o CodeBlocks e tamb√©m possui um tamanho muito maior (alguns GB, no momento que escrevemos este texto, em 2026). Portanto, nossa recomenda√ß√£o para iniciar, ficar com algo mais simples. Se tamanho e complexidade n√£o s√£o um problema, recomendo testar a ferramenta.

## O primeiro programa

Todo programa C++ execut√°vel precisa de uma fun√ß√£o chamada `main`: √© por ela
que a execu√ß√£o come√ßa. Um exemplo m√≠nimo que s√≥ imprime uma mensagem √©:

```cpp
#include <iostream>

int main() {
    std::cout << "Ol√°, mundo!" << std::endl;
    return 0;
}
```

O que aparece a√≠:

- **`#include <iostream>`** ‚Äî inclui a parte da biblioteca padr√£o que permite
  entrada e sa√≠da (ler do teclado e imprimir na tela).
- **`int main()`** ‚Äî define a fun√ß√£o principal; o programa come√ßa aqui.
- **`std::cout << ...`** ‚Äî envia o que est√° √† direita para a sa√≠da padr√£o (o
  terminal). `std::endl` pula uma linha.
- **`return 0;`** ‚Äî indica que o programa terminou sem erro (conven√ß√£o para o
  sistema operacional).

Salve o c√≥digo em um arquivo, por exemplo `ola.cpp`. Se voc√™ estiver no MacOS ou no Linux, no terminal, na pasta do
arquivo:

```bash
g++ -o ola ola.cpp
./ola
```

(O primeiro comando gera o execut√°vel `ola`; o segundo roda. No Windows, use
`ola.exe` ou apenas `ola` dependendo do ambiente.)

:::tip[Quem estiver utilizando o Code Blocks]

Para quem estiver utilizando o CodeBlocks, verificar o processo de criar projetos no v√≠deo a seguir:

<iframe width="560" height="315" src="https://www.youtube.com/embed/Hkpwf5UJSmo?si=ue9ySmqLr_o1oCT4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

:::

Em C++, a biblioteca padr√£o (entrada/sa√≠da, strings, containers, etc.) fica no
*namespace std*. O prefixo *std::* indica que o nome que vem em seguida
pertence a esse namespace ‚Äî por exemplo, `std::cout` √© o cout da biblioteca
padr√£o. Isso evita conflito com outros nomes: se voc√™ criar uma vari√°vel ou
fun√ß√£o chamada cout no seu c√≥digo, ela n√£o se mistura com o cout da biblioteca,
que continua sendo std::cout. Usar std:: deixa expl√≠cito que voc√™ est√° usando
recursos da biblioteca padr√£o e √© uma pr√°tica comum em material did√°tico e em
projetos que preferem clareza √† economia de digita√ß√£o.

Para n√£o precisar escrever std:: toda vez, podemos usar a diretiva using. Com
using namespace std;, todos os nomes do namespace std passam a ser usados sem
prefixo no arquivo (ou no bloco) em que a diretiva aparece. Outra op√ß√£o √© ser
mais seletivo: using std::cout; e using std::cin; trazem s√≥ cout e cin para o
escopo, reduzindo o risco de conflitos. Em c√≥digos pequenos ou em material
introdut√≥rio isso deixa o programa mais curto e leg√≠vel; em projetos maiores
costuma-se evitar using namespace std no topo do arquivo para n√£o "poluir" o
escopo com todos os nomes da biblioteca padr√£o.

## Vari√°veis e Tipos Primitivos

C++ √© uma linguagem fortemente tipada. As vari√°veis devem ser declaradas com um
tipo espec√≠fico.
```cpp
#include <iostream>

int main() {
    int idade = 25;           // Inteiro
    double altura = 1.75;     // Ponto flutuante (precis√£o dupla)
    char letra = 'A';         // Caractere √∫nico
    bool programador = true;  // Booleano (true/false)
    
    // std::string requer #include <string>, mas √© fundamental conhecer
    // (Veremos mais em STL)
    
    std::cout << "Idade: " << idade << std::endl;
    std::cout << "Altura: " << altura << std::endl;
    
    return 0;
}
```

### Infer√™ncia de Tipo (`auto`)

A partir do C++11, a palavra-chave `auto` permite que o compilador deduza o
tipo da vari√°vel com base no valor de inicializa√ß√£o. Isso √© √∫til para reduzir a
verbosidade, especialmente com tipos complexos.

```cpp
auto x = 10;        // Deduzido como int
auto y = 3.14;      // Deduzido como double
auto z = "Texto";   // Deduzido como const char*

// O tipo √© fixo ap√≥s a dedu√ß√£o. N√£o √© tipagem din√¢mica!
// x = "Erro"; // Isso causaria erro de compila√ß√£o
```

## Entrada e Sa√≠da

A biblioteca `<iostream>` fornece `std::cin` para entrada e `std::cout` para
sa√≠da.

```cpp
#include <iostream>

int main() {
    int numero;
    
    std::cout << "Digite um n√∫mero: ";
    std::cin >> numero; // L√™ o input do usu√°rio e armazena em 'numero'
    
    std::cout << "Voc√™ digitou: " << numero << std::endl;
    
    return 0;
}
```

:::tip[namespace]

Um namespace em C++ √© um mecanismo que agrupa nomes (vari√°veis, fun√ß√µes,
classes, etc.) dentro de um "espa√ßo de nomes". Assim, o mesmo identificador
pode existir em namespaces diferentes sem conflito: por exemplo, std::cout e um
cout definido em outro namespace s√£o coisas distintas. O compilador usa o
namespace para saber exatamente qual entidade voc√™ est√° referenciando. A
biblioteca padr√£o do C++ coloca seus recursos no namespace std; por isso
usamos std::cout, std::cin, etc. Namespaces ajudam a organizar c√≥digo grande,
a evitar colis√µes de nomes entre bibliotecas e a deixar expl√≠cita a origem de
cada nome.

Voc√™ usa um nome de um namespace de duas formas: com o nome qualificado (ex.:
std::cout) ou trazendo o nome para o escopo atual com using (ex.: using
std::cout; ou using namespace std;). Definir um namespace seu √© feito com a
palavra-chave namespace seguida do nome e de um bloco { } com as declara√ß√µes.
Em resumo: namespace √© o "sobrenome" que desambigua e organiza os nomes no
C++.

Mas calma! Vamos retomar esse conceito quando avan√ßarmos mais com a linguagem!

:::

## Estruturas de Controle

As estruturas de controle em C++ s√£o muito semelhantes √†s de C, Java e C#. Elas permitem que o nosso programa execute ou n√£o trechos de c√≥digo e determine como ser√° a sua execu√ß√£o dado um conjunto de valores ou estados que nosso programa pode assumir. Al√©m das estruturas de controle condicional, temos as estruturas de repeti√ß√£o. Elas permitem que um trecho do nosso programa possa ser repetido enquanto uma determinada condi√ß√£o for verdadeira.

### Condicionais

```cpp
int x = 10;

if (x > 0) {
    std::cout << "Positivo";
} else if (x < 0) {
    std::cout << "Negativo";
} else {
    std::cout << "Zero";
}
```

### La√ßos de Repeti√ß√£o

```cpp
// Loop For
for (int i = 0; i < 5; i++) {
    std::cout << i << " ";
}
// Sa√≠da: 0 1 2 3 4

// Loop While
int contador = 0;
while (contador < 3) {
    std::cout << "Contando: " << contador << "\n";
    contador++;
}
```

## Fun√ß√µes

Fun√ß√µes s√£o agrupamentos de c√≥digo que podem ser reutilizados em diversos pontos do nosso programa. Al√©m da reutiliza√ß√£o, quando utilizamos fun√ß√µes, torna-se mais direto o processo de modulariza√ß√£o do c√≥digo, deixando trechos mais bem definidos e simples de trabalhar e modificar.

Vamos analisar o exemplo abaixo. Este exemplo ainda n√£o utiliza fun√ß√µes.

```cpp
#include <iostream>

using namespace std;

int main() {
    int a, b;
    cout << "Digite dois n√∫meros: ";
    cin >> a >> b;

    int soma = a + b;
    cout << "Soma: " << soma << endl;

    return 0;
}
```

- **`cin >> a >> b`** ‚Äî l√™ dois valores do teclado e armazena em `a` e `b`
  (separados por espa√ßo ou Enter).
- **`int soma = a + b`** ‚Äî calcula a soma e guarda em uma nova vari√°vel.

Esse √© o padr√£o b√°sico: declarar vari√°veis, ler com `cin`, fazer c√°lculos e
mostrar resultados com `cout`.

Resumo do fluxo: escrever, compilar, executar:

1. **Escrever** o c√≥digo em um arquivo (por exemplo `.cpp`).
2. **Compilar** com o compilador (ex.:
   `g++ -o meu_programa meu_programa.cpp`).
3. **Executar** o programa gerado (ex.: `./meu_programa` no Linux/macOS ou
   `meu_programa.exe` no Windows).

Se houver erro de sintaxe, o compilador mostra mensagens na linha em que
detectou o problema. Corrija o c√≥digo e compile de novo.

Voc√™ tamb√©m pode criar suas pr√≥prias fun√ß√µes. Em C++, √© comum separar a
declara√ß√£o (prot√≥tipo) da defini√ß√£o:

```cpp
// Declara√ß√£o da fun√ß√£o (prot√≥tipo)
int somar(int a, int b);

int main() {
    int resultado = somar(5, 3);
    std::cout << "A soma √©: " << resultado << std::endl;
    return 0;
}

// Defini√ß√£o da fun√ß√£o
int somar(int a, int b) {
    return a + b;
}
```

O que aconteceu aqui, retiramos o comportamento de somar os dois n√∫meros do programa principal e deixamos ele separado do nosso programa principal. Desta forma, ele pode ser utilizado em diversos pontos, al√©m de ficar mais direto e simples alterar e corrigir esse comportamento se for necess√°rio.

> `Calma l√°, voc√™s est√£o dizendo que mudar esse c√≥digo simples vai ser um problema?`

Aqui tem um ponto importante para analisarmos: muitos exemplos que vamos passar aqui tem uma caracter√≠stica de demonstrar algum comportamento. Para tornar mais simples o processo de compreender o que estamos apresentando, estes exemplos ser√£o mais simples. Contudo, com o passar do tempo e do material, a sua complexidade ser√° elevada. Neste momento, eles s√£o simples de forma proposital, para demonstrar o conceito em sua forma mais b√°sica beleza?