---
title: A STL
sidebar:
  order: 4
slug: cpp-stl
---

Este artigo mostra por que templates existem, como usá‑los no básico e como a
STL (containers + algoritmos) resolve problemas comuns. Itens marcados como
"Novo" requerem suporte de padrão mais recente (C++20/C++23).

## Motivação: sem templates

Problema clássico: duas funções com a mesma lógica para tipos diferentes.

```cpp
int dobrar(int x) { return x * 2; }
double dobrar(double x) { return x * 2; }

int main() {
  std::cout << dobrar(2) << "\n";
  std::cout << dobrar(2.5) << "\n";
}
```

Manutenção pior, duplicação de código. Em C++, evitamos isso com templates.

## Entendendo templates

### Funções template

```cpp
template<typename T>
T dobrar(T x) { return x * 2; }

int main() {
  std::cout << dobrar(2) << "\n";
  std::cout << dobrar(2.5) << "\n";
}
```

- Dedução de tipo funciona na maioria dos casos.
- Chamada explícita: `dobrar<int>(2)`.
- `typename` e `class` são equivalentes em templates simples.

### Classes template (rápido)

```cpp
template<typename T>
struct Caixa { T valor; };

int main() {
  Caixa<int> c{42};
  Caixa<std::string> s{"oi"};
  std::cout << c.valor << " " << s.valor << "\n";
}
```

Compilação:
- `g++ -std=c++17 -O0 -g arquivo.cpp -o exec`

## A STL na prática

A STL é um conjunto de templates prontos: containers, iteradores e algoritmos.

### Containers essenciais

- `std::vector<T>`: arranjo dinâmico.
- `std::string`: texto.
- `std::unordered_map<K,V>`: dicionário hash (chave/valor).

### Iteração e algoritmos

Prefira algoritmos a loops manuais quando existir equivalente.

```cpp
#include <vector>
#include <algorithm>
#include <numeric>
#include <iostream>

int main() {
  std::vector<int> v{3,1,4,1,5};
  std::sort(v.begin(), v.end());
  int soma = std::accumulate(v.begin(), v.end(), 0);
  std::cout << soma << "\n";
}
```

### Map simples

```cpp
#include <unordered_map>
#include <string>
#include <iostream>

int main() {
  std::unordered_map<std::string,int> freq;
  for (auto s : {"um","um","dois"}) freq[s]++;
  std::cout << freq["um"] << " " << freq["dois"] << "\n";
}
```

## Novidades

### C++17

- `std::string_view`: visão leve de string, evita cópia.

```cpp
#include <string_view>
#include <iostream>

void print(std::string_view s) { std::cout << s << "\n"; }
```

### C++20 (Novo)

- `<ranges>`: pipelines legíveis com views e algoritmos.

```cpp
#include <ranges>
#include <vector>
#include <iostream>

int main() {
  using std::views::filter;
  using std::views::transform;
  std::vector<int> v{1,2,3,4,5,6};
  auto evens_squared = v
    | filter([](int x){ return x % 2 == 0; })
    | transform([](int x){ return x * x; });
  for (int x : evens_squared) std::cout << x << "\n";
}
```

- `std::span`: visão sobre dados contíguos.

```cpp
#include <span>
#include <iostream>

void soma(std::span<const int> xs) {
  int s = 0; for (int x : xs) s += x; std::cout << s << "\n";
}
```

- `unordered_map::contains`: checar se chave existe.

```cpp
#include <unordered_map>

bool tem(const std::unordered_map<int,int>& m, int k) {
  return m.contains(k);
}
```

### C++23 (Novo)

- `std::ranges::to`: coletar resultados de pipelines (suporte varia).

```cpp
// Pode requerer lib/compilador recente
#include <ranges>
#include <vector>

int main() {
  std::vector<int> v{1,2,3,4};
  auto out = v | std::views::transform([](int x){return x+1;})
               | std::ranges::to<std::vector<int>>();
}
```

## Boas práticas e pegadinhas

- Inclua os headers corretos: `<algorithm>`, `<numeric>`, `<ranges>`, etc.
- Inserções/remoções podem invalidar iteradores.
- Use `auto` para tipos verbosos; `auto&` ao iterar se precisa modificar.
- Combine STL com smart pointers quando houver polimorfismo.

## Comandos

- C++17: `g++ -std=c++17 -O0 -g arquivo.cpp -o exec`
- C++20: `g++ -std=c++20 -O0 -g arquivo.cpp -o exec`
- C++23: `g++ -std=c++23 -O0 -g arquivo.cpp -o exec`
