---
title: Gerenciamento de memória
description: Entenda como funciona o gerenciamento de memória em C++, desde o modelo de von Neumann até smart pointers modernos.
sidebar:
  order: 2
slug: cpp-memoria
---

import { Image } from 'astro:assets';
import vonNeumann from '../../../../assets/linguagens/cpp/von_neumann.jpg';

Você já parou para pensar no que diferencia as linguagens de alto nível das
linguagens de baixo nível, as chamadas linguagens de sistema? Talvez você já
tenha ouvido falar do termo *garbage collector* e não tenha entendido
exatamente o que aquilo significava ou por que isso torna linguagens mais
lentas.

Para entender melhor o que tudo isso significa, vamos falar um pouco sobre
memória. Para isso, vou voltar um pouco no tempo.

## O modelo de von Neumann

A arquitetura de von Neumann, proposta pelo matemático John von Neumann em
1945, revolucionou a computação ao introduzir um conceito simples mas
poderoso: instruções e dados devem ser armazenados na mesma memória. Antes
disso, programas eram frequentemente hardcoded ou configurados manualmente
através de chaves e cabos.

<center>
  <Image
    src={vonNeumann}
    alt="Arquitetura de von Neumann"
    style={{ height: 'auto' }}
  />
</center>
<p><center>A arquitetura de von Neumann introduziu o conceito de instruções e
  variáveis armazenadas em memória.</center></p>

Neste modelo, a CPU busca, decodifica e executa instruções em um ciclo
contínuo conhecido como fetch-decode-execute. A memória é única tanto para
o programa quanto para os dados, e é endereçada diretamente pela CPU.
Dispositivos de entrada e saída se comunicam com o sistema através de
barramentos.

Uma consequência fundamental desta arquitetura é que programa e dados
compartilham o mesmo espaço de memória. As instruções são armazenadas como
números na memória, e ponteiros nada mais são do que endereços que
referenciam dados. Os conceitos de stack e heap não são definidos pelo
hardware da CPU, mas sim pelo sistema operacional e pela ABI
(Application Binary Interface).

Esta visão ajuda a entender por que em C++ falamos frequentemente em
endereços de memória, ponteiros, frames de stack e objetos alocados no
heap. O controle direto sobre esses elementos é o que caracteriza uma
linguagem de sistema.

## Hierarquia de memória

Nem toda memória é igual. Se você já notou que seu computador tem memória
RAM e um disco rígido, talvez se pergunte por que precisamos de ambos. A
resposta está na hierarquia de memória, um conceito fundamental em
arquitetura de computadores.

A memória do computador é organizada em níveis que oferecem diferentes
compromissos entre velocidade, capacidade e custo. Os registradores da CPU
são os mais rápidos, mas existem em quantidade muito limitada, tipicamente
apenas algumas dezenas. O cache, dividido em níveis L1, L2 e às vezes L3,
oferece velocidade intermediária com capacidade maior, variando de
kilobytes a megabytes.

A memória RAM, ou memória principal, é onde seus programas residem durante
a execução. Ela é significativamente mais lenta que o cache, mas oferece
gigabytes de capacidade. Finalmente, o armazenamento secundário, como SSDs
e discos rígidos, oferece capacidade massiva mas com latência muito maior.

Quando você escreve um programa em C++, está trabalhando principalmente
com a memória RAM. Entender esta hierarquia é crucial porque o desempenho
do seu programa depende muito de como você acessa a memória. Acessos
sequenciais e previsíveis são muito mais eficientes que acessos aleatórios.

## Stack vs heap

Dentro da memória RAM disponível para seu programa, existem duas regiões
principais onde seus dados podem residir: a pilha (stack) e o heap.

A pilha é uma região de memória gerenciada automaticamente pelo compilador.
Quando você declara uma variável local dentro de uma função, ela é
alocada na pilha. A alocação é extremamente rápida, envolvendo apenas o
deslocamento de um ponteiro de pilha. Quando a função termina, todas as
variáveis locais são automaticamente desalocadas. A vida útil dos objetos
na pilha está estritamente ligada ao escopo em que foram criados.

O heap, por outro lado, é uma região de memória gerenciada manualmente pelo
programador. Quando você precisa de memória que deve persistir além do
escopo de uma função, ou quando o tamanho necessário só é conhecido em
tempo de execução, você aloca no heap usando operadores como `new`.
Esta memória permanece alocada até que você explicitamente a libere com
`delete`, ou até que o programa termine.

A diferença de desempenho entre stack e heap é significativa. A pilha
oferece alocação e desalocação praticamente instantâneas, enquanto o heap
requer chamadas ao sistema operacional e gerenciamento de estruturas de
dados complexas. Além disso, a memória da pilha geralmente já está no
cache da CPU devido à sua natureza sequencial e previsível.

Então por que não usamos apenas a pilha? A limitação fundamental é que o
tamanho da pilha é fixo e relativamente pequeno, tipicamente alguns
megabytes. Alocar objetos muito grandes na pilha pode causar estouro de
pilha (stack overflow). Além disso, a pilha não permite que objetos
sobrevivam ao escopo onde foram criados, o que é necessário em muitos
padrões de programação.

## Pedindo memória para o sistema

Quando seu programa precisa de mais memória no heap, ele faz uma requisição
ao sistema operacional através de chamadas de sistema (syscalls). Em
sistemas Unix-like, a syscall `brk` ou `mmap` é usada para expandir a
região de memória do heap. O sistema operacional mantém estruturas de dados
complexas para rastrear quais páginas de memória estão livres e quais
estão alocadas.

O alocador de memória padrão do C++ (geralmente implementado usando
malloc/free por baixo) gerencia um pool de memória obtida do sistema.
Quando você chama `new`, o alocador tenta encontrar um bloco livre
dentro deste pool. Se não houver memória suficiente, ele pede mais ao
sistema operacional. Quando você chama `delete`, a memória é devolvida ao
pool, mas não necessariamente ao sistema operacional imediatamente.

Este gerenciamento tem overhead significativo. Cada alocação no heap
requer buscar um bloco adequado, possivelmente dividir blocos maiores, e
atualizar estruturas de metadados. Por isso, alocações frequentes e
pequenas no heap são ineficientes e devem ser evitadas quando possível.

## Ponteiros clássicos

Ponteiros crus oferecem controle total sobre a memória, mas este poder vem
com responsabilidade. Erros com ponteiros são uma das principais fontes
de bugs em C++.

```cpp
#include <iostream>

int main() {
  int* p = new int(42);
  std::cout << *p << "\n";
  delete p; // obrigatório
}
```

Quando trabalhamos com arrays alocados dinamicamente, devemos usar `delete[]`
em vez de `delete` simples:

```cpp
int* arr = new int[10];
arr[0] = 7;
delete[] arr; // não use delete simples aqui
```

A diferença é crucial: `delete` simples chama o destrutor apenas do primeiro
elemento, enquanto `delete[]` chama o destrutor de cada elemento do array.
Usar o operador errado resulta em comportamento indefinido.

Os erros mais comuns com ponteiros crus incluem confundir `delete` com
`delete[]`, chamar `delete` duas vezes no mesmo ponteiro (double free),
usar um ponteiro após liberar a memória (dangling pointer), e retornos
precoces ou exceções que fazem o programa pular a chamada de `delete`.

Felizmente, a maioria destes problemas desaparece quando adotamos o
princípio RAII (Resource Acquisition Is Initialization) e usamos
containers e smart pointers da biblioteca padrão.

## Vazamento de memória

Um vazamento de memória ocorre quando alocamos memória no heap mas
esquecemos de liberá-la. Considere este exemplo problemático:

```cpp
// leak.cpp
#include <iostream>

struct Foo { int x{42}; };

void f(bool fail) {
  Foo* p = new Foo();
  if (fail) return; // vazou - delete nunca é chamado
  std::cout << p->x << "\n";
  delete p;
}

int main() { f(true); }
```

Se a função retornar prematuramente devido a `fail` ser true, a memória
alocada nunca é liberada. Em um programa real, vazamentos como este
acumulados ao longo do tempo podem esgotar a memória disponível.

Podemos detectar vazamentos usando ferramentas como o Valgrind:

```bash
g++ -std=c++17 -O0 -g leak.cpp -o leak
valgrind --leak-check=full ./leak
```

O relatório do Valgrind indicará algo como `definitely lost: 16 bytes in
1 blocks`, confirmando que há memória alocada que não foi liberada.

A solução elegante é usar `std::unique_ptr`, que gerencia automaticamente
a vida do objeto:

```cpp
// leak_fixed.cpp
#include <iostream>
#include <memory>

struct Foo { int x{42}; };

void f(bool fail) {
  auto p = std::make_unique<Foo>();
  if (fail) return; // objeto é destruído automaticamente
  std::cout << p->x << "\n";
}

int main() { f(true); }
```

Com `std::unique_ptr`, não precisamos nos preocupar com caminhos de retorno
ou exceções. O objeto é sempre destruído quando o ponteiro sai de escopo.

## Ponteiros inteligentes

A biblioteca `<memory>` oferece três tipos de smart pointers que gerenciam
automaticamente a vida dos objetos, eliminando a necessidade de chamadas
explícitas a `delete`.

O `std::unique_ptr` representa propriedade exclusiva sobre um objeto. Ele
é leve, não adiciona overhead em comparação com ponteiros crus, e não pode
ser copiado, apenas movido. Sempre que possível, prefira criar unique_ptr
usando `std::make_unique`.

```cpp
#include <memory>
#include <iostream>

int main() {
  auto p = std::make_unique<int>(42);
  std::cout << *p << "\n";
  auto q = std::move(p); // transfere propriedade; p vira nullptr
}
```

Quando precisamos transferir a propriedade para uma função, usamos
`std::move`:

```cpp
#include <memory>
#include <iostream>

void consume(std::unique_ptr<int> p) {
  std::cout << *p << "\n";
}

int main() {
  auto p = std::make_unique<int>(42);
  consume(std::move(p)); // p fica vazio após a chamada
}
```

Para arrays, o unique_ptr possui uma especialização que gerencia a
memória corretamente:

```cpp
#include <memory>

int main() {
  std::unique_ptr<int[]> arr(new int[10]);
  arr[0] = 7;
  // delete[] é chamado automaticamente ao sair do escopo
}
```

O `std::shared_ptr` implementa propriedade compartilhada através de
contagem de referências. Cada cópia do shared_ptr incrementa um contador,
e cada destruição decrementa. Quando o contador chega a zero, o objeto é
destruído.

```cpp
#include <memory>
#include <iostream>

int main() {
  auto sp1 = std::make_shared<std::string>("oi");
  auto sp2 = sp1; // contagem incrementada para 2
  std::cout << sp1.use_count() << "\n"; // imprime 2
}
```

Shared pointers têm overhead de desempenho devido à contagem de
referências thread-safe. Use apenas quando a vida do objeto realmente
precisa ser compartilhada entre múltiplos proprietários.

Um problema com shared_ptr é a possibilidade de ciclos de referência,
onde dois objetos se referenciam mutuamente, impedindo que ambos sejam
destruídos:

```cpp
#include <memory>

struct B;
struct A { std::shared_ptr<B> b; };
struct B { std::shared_ptr<A> a; };

int main() {
  auto a = std::make_shared<A>();
  auto b = std::make_shared<B>();
  a->b = b;
  b->a = a; // ciclo criado: nenhum objeto será destruído
}
```

Para resolver este problema, usamos `std::weak_ptr`, que funciona como um
observador que não mantém o objeto vivo:

```cpp
#include <memory>
#include <iostream>

struct B;
struct A { std::weak_ptr<B> b; }; // weak em vez de shared
struct B { std::shared_ptr<A> a; };

int main() {
  auto a = std::make_shared<A>();
  auto b = std::make_shared<B>();
  a->b = b;
  b->a = a; // sem ciclo forte: ambos serão destruídos

  if (auto locked = a->b.lock()) {
    std::cout << "Ainda vivo, pode usar\n";
  }
}
```

O método `lock()` converte o weak_ptr em um shared_ptr temporário se o
objeto ainda existir, ou retorna nullptr se já foi destruído.

## Guia rápido de escolha

A escolha da ferramenta de gerenciamento de memória depende do padrão de
propriedade que seu código precisa expressar.

Sempre que possível, prefira containers da biblioteca padrão como
`std::vector` e `std::string`, ou simplesmente objetos locais na pilha.
Estas opções são seguras, eficientes e eliminam preocupações com
gerenciamento manual.

Quando você precisa expressar propriedade única de um objeto no heap, o
`std::unique_ptr` é a escolha padrão. Ele é eficiente, seguro e torna
explícito que há apenas um dono do recurso.

Para situações onde múltiplas partes do código precisam compartilhar a
propriedade de um objeto, use `std::shared_ptr`. Esteja ciente do overhead
e dos riscos de ciclos de referência.

Quando você precisa observar um objeto gerenciado por shared_ptr sem
afetar sua vida útil, ou quando precisa quebrar ciclos de referência,
o `std::weak_ptr` é a ferramenta apropriada.

Ponteiros crus e referências ainda têm seu lugar, mas devem ser usados
apenas para acesso temporário sem assumir propriedade. Nunca chame `delete`
manualmente em um ponteiro cru quando alternativas modernas estão
disponíveis.

## Comandos úteis

Para compilar exemplos com símbolos de debug, útil para ferramentas como
Valgrind: `g++ -std=c++17 -O0 -g arquivo.cpp -o exec`

Para detectar vazamentos de memória com Valgrind:
`valgrind --leak-check=full ./exec`
