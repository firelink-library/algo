---
title: Gerenciamento de memória
description: Entenda como funciona o gerenciamento de memória em C++, desde o modelo de von Neumann até smart pointers modernos.
sidebar:
  order: 2
slug: cpp-memoria
---

import { Image } from 'astro:assets';
import vonNeumann from '../../../../assets/linguagens/cpp/von_neumann.jpg';

Você já parou para pensar no que diferencia as linguagens de alto nível das
linguagens de baixo nível, as chamadas linguagens de sistema? Talvez você já
tenha ouvido falar do termo *garbage collector* e não tenha entendido
exatamente o que aquilo significava ou por que isso torna linguagens mais
lentas.

Para entender melhor o que tudo isso significa, vamos falar um pouco sobre
memória. Para isso, vou voltar um pouco no tempo.

## O modelo de von Neumann

A arquitetura de von Neumann, proposta pelo matemático John von Neumann em
1945, revolucionou a computação ao introduzir um conceito simples mas
poderoso: instruções e dados devem ser armazenados na mesma memória. Antes
disso, programas eram frequentemente hardcoded ou configurados manualmente
através de chaves e cabos.

<center>
  <Image
    src={vonNeumann}
    alt="Arquitetura de von Neumann"
    style={{ height: 'auto' }}
  />
</center>
<p><center>A arquitetura de von Neumann introduziu o conceito de instruções e
  variáveis armazenadas em memória.</center></p>

Neste modelo, a CPU busca, decodifica e executa instruções em um ciclo
contínuo conhecido como fetch-decode-execute. A memória é única tanto para
o programa quanto para os dados, e é endereçada diretamente pela CPU.
Dispositivos de entrada e saída se comunicam com o sistema através de
barramentos.

Uma consequência fundamental desta arquitetura é que programa e dados
compartilham o mesmo espaço de memória. As instruções são armazenadas como
números na memória, e ponteiros nada mais são do que endereços que
referenciam dados. Os conceitos de stack e heap não são definidos pelo
hardware da CPU, mas sim pelo sistema operacional e pela ABI
(Application Binary Interface).

Esta visão ajuda a entender por que em C++ falamos frequentemente em
endereços de memória, ponteiros, frames de stack e objetos alocados no
heap. O controle direto sobre esses elementos é o que caracteriza uma
linguagem de sistema.

## Hierarquia de memória

Nem toda memória é igual. Se você já notou que seu computador tem memória
RAM e um disco rígido, talvez se pergunte por que precisamos de ambos. A
resposta está na hierarquia de memória, um conceito fundamental em
arquitetura de computadores.

A memória do computador é organizada em níveis que oferecem diferentes
compromissos entre velocidade, capacidade e custo. Os registradores da CPU
são os mais rápidos, mas existem em quantidade muito limitada, tipicamente
apenas algumas dezenas. O cache, dividido em níveis L1, L2 e às vezes L3,
oferece velocidade intermediária com capacidade maior, variando de
kilobytes a megabytes.

A memória RAM, ou memória principal, é onde seus programas residem durante
a execução. Ela é significativamente mais lenta que o cache, mas oferece
gigabytes de capacidade. Finalmente, o armazenamento secundário, como SSDs
e discos rígidos, oferece capacidade massiva mas com latência muito maior.

Quando você escreve um programa em C++, está trabalhando principalmente
com a memória RAM. Entender esta hierarquia é crucial porque o desempenho
do seu programa depende muito de como você acessa a memória. Acessos
sequenciais e previsíveis são muito mais eficientes que acessos aleatórios.

## Stack vs heap

Dentro da memória RAM disponível para seu programa, existem duas regiões
principais onde seus dados podem residir: a pilha (stack) e o heap.

A pilha é uma região de memória gerenciada automaticamente pelo compilador.
Quando você declara uma variável local dentro de uma função, ela é
alocada na pilha. A alocação é extremamente rápida, envolvendo apenas o
deslocamento de um ponteiro de pilha. Quando a função termina, todas as
variáveis locais são automaticamente desalocadas. A vida útil dos objetos
na pilha está estritamente ligada ao escopo em que foram criados.

O heap, por outro lado, é uma região de memória gerenciada manualmente pelo
programador. Quando você precisa de memória que deve persistir além do
escopo de uma função, ou quando o tamanho necessário só é conhecido em
tempo de execução, você aloca no heap usando operadores como `new`.
Esta memória permanece alocada até que você explicitamente a libere com
`delete`, ou até que o programa termine.

A diferença de desempenho entre stack e heap é significativa. A pilha
oferece alocação e desalocação praticamente instantâneas, enquanto o heap
requer chamadas ao sistema operacional e gerenciamento de estruturas de
dados complexas. Além disso, a memória da pilha geralmente já está no
cache da CPU devido à sua natureza sequencial e previsível.

Então por que não usamos apenas a pilha? A limitação fundamental é que o
tamanho da pilha é fixo e relativamente pequeno, tipicamente alguns
megabytes. Alocar objetos muito grandes na pilha pode causar estouro de
pilha (stack overflow). Além disso, a pilha não permite que objetos
sobrevivam ao escopo onde foram criados, o que é necessário em muitos
padrões de programação.

## Pedindo memória para o sistema

Quando seu programa precisa de mais memória no heap, ele faz uma requisição
ao sistema operacional através de chamadas de sistema (syscalls). Em
sistemas Unix-like, a syscall `brk` ou `mmap` é usada para expandir a
região de memória do heap. O sistema operacional mantém estruturas de dados
complexas para rastrear quais páginas de memória estão livres e quais
estão alocadas.

O alocador de memória padrão do C++ (geralmente implementado usando
malloc/free por baixo) gerencia um pool de memória obtida do sistema.
Quando você chama `new`, o alocador tenta encontrar um bloco livre
dentro deste pool. Se não houver memória suficiente, ele pede mais ao
sistema operacional. Quando você chama `delete`, a memória é devolvida ao
pool, mas não necessariamente ao sistema operacional imediatamente.

Este gerenciamento tem overhead significativo. Cada alocação no heap
requer buscar um bloco adequado, possivelmente dividir blocos maiores, e
atualizar estruturas de metadados. Por isso, alocações frequentes e
pequenas no heap são ineficientes e devem ser evitadas quando possível.

## Ponteiros clássicos

Ponteiros crus oferecem controle total sobre a memória, mas este poder vem
com responsabilidade. Erros com ponteiros são uma das principais fontes
de bugs em C++.

```cpp
#include <iostream>

int main() {
  int* p = new int(42);
  std::cout << *p << "\n";
  delete p; // obrigatório
}
```

Quando trabalhamos com arrays alocados dinamicamente, devemos usar `delete[]`
em vez de `delete` simples:

```cpp
int* arr = new int[10];
arr[0] = 7;
delete[] arr; // não use delete simples aqui
```

A diferença é crucial: `delete` simples chama o destrutor apenas do primeiro
elemento, enquanto `delete[]` chama o destrutor de cada elemento do array.
Usar o operador errado resulta em comportamento indefinido.

Os erros mais comuns com ponteiros crus incluem confundir `delete` com
`delete[]`, chamar `delete` duas vezes no mesmo ponteiro (double free),
usar um ponteiro após liberar a memória (dangling pointer), e retornos
precoces ou exceções que fazem o programa pular a chamada de `delete`.

Felizmente, a maioria destes problemas desaparece quando adotamos o
princípio RAII (Resource Acquisition Is Initialization) e usamos
containers e smart pointers da biblioteca padrão.

## Vazamento de memória

Um vazamento de memória ocorre quando alocamos memória no heap mas
esquecemos de liberá-la. Considere este exemplo problemático:

```cpp
// leak.cpp
#include <iostream>

struct Foo { int x{42}; };

void f(bool fail) {
  Foo* p = new Foo();
  if (fail) return; // vazou - delete nunca é chamado
  std::cout << p->x << "\n";
  delete p;
}

int main() { f(true); }
```

Se a função retornar prematuramente devido a `fail` ser true, a memória
alocada nunca é liberada. Em um programa real, vazamentos como este
acumulados ao longo do tempo podem esgotar a memória disponível.

Podemos detectar vazamentos usando ferramentas como o Valgrind:

```bash
g++ -std=c++17 -O0 -g leak.cpp -o leak
valgrind --leak-check=full ./leak
```

O relatório do Valgrind indicará algo como `definitely lost: 16 bytes in
1 blocks`, confirmando que há memória alocada que não foi liberada.

A solução elegante é usar `std::unique_ptr`, que gerencia automaticamente
a vida do objeto:

```cpp
// leak_fixed.cpp
#include <iostream>
#include <memory>

struct Foo { int x{42}; };

void f(bool fail) {
  auto p = std::make_unique<Foo>();
  if (fail) return; // objeto é destruído automaticamente
  std::cout << p->x << "\n";
}

int main() { f(true); }
```

Com `std::unique_ptr`, não precisamos nos preocupar com caminhos de retorno
ou exceções. O objeto é sempre destruído quando o ponteiro sai de escopo.

## Ponteiros inteligentes

A biblioteca `<memory>` oferece três tipos de smart pointers que gerenciam
automaticamente a vida dos objetos. Eles eliminam a necessidade de chamadas
explícitas a `delete` e previnem os erros mais comuns de gerenciamento de
memória.

### unique_ptr

O `std::unique_ptr` representa propriedade exclusiva sobre um objeto. Ele
é leve, não adiciona overhead em comparação com ponteiros crus, e não pode
ser copiado, apenas movido. Quando o unique_ptr sai de escopo, o objeto
apontado é automaticamente destruído.

Sempre que possível, crie unique_ptr usando `std::make_unique` em vez de
chamar `new` diretamente. Isso é mais seguro e eficiente:

```cpp
#include <memory>
#include <iostream>

int main() {
  auto p = std::make_unique<int>(42);
  std::cout << *p << "\n";
  auto q = std::move(p); // transfere propriedade; p vira nullptr
}
```

A semântica de movimento é fundamental aqui. Quando transferimos um
unique_ptr para outra variável ou função, a propriedade é movida, não
copiada. O ponteiro original fica vazio (nullptr) após a operação.

Para transferir propriedade para uma função:

```cpp
#include <memory>
#include <iostream>

void consume(std::unique_ptr<int> p) {
  std::cout << *p << "\n";
}

int main() {
  auto p = std::make_unique<int>(42);
  consume(std::move(p)); // p fica vazio após a chamada
}
```

Para arrays alocados dinamicamente, o unique_ptr possui uma
especialização que gerencia a memória corretamente, chamando `delete[]`
automaticamente:

```cpp
#include <memory>

int main() {
  std::unique_ptr<int[]> arr(new int[10]);
  arr[0] = 7;
  // delete[] é chamado automaticamente ao sair do escopo
}
```

Use unique_ptr como padrão sempre que precisar de propriedade única de um
objeto no heap. Ele é eficiente, seguro e torna explícito que há apenas
um dono do recurso.

### shared_ptr

O `std::shared_ptr` implementa propriedade compartilhada através de
contagem de referências. Cada cópia do shared_ptr incrementa um contador
atômico, e cada destruição decrementa. Quando o contador chega a zero, o
objeto é destruído automaticamente.

```cpp
#include <memory>
#include <iostream>

int main() {
  auto sp1 = std::make_shared<std::string>("oi");
  auto sp2 = sp1; // contagem incrementada para 2
  std::cout << sp1.use_count() << "\n"; // imprime 2
  // Quando sp1 e sp2 saírem de escopo, o objeto será destruído
}
```

Shared pointers têm overhead significativo devido à contagem de
referências thread-safe. Use apenas quando a vida do objeto realmente
precisa ser compartilhada entre múltiplos proprietários que não têm uma
relação clara de pai-filho.

Um problema sério com shared_ptr é a possibilidade de ciclos de
referência. Quando dois objetos se referenciam mutuamente via shared_ptr,
cada um mantém o outro vivo, impedindo que ambos sejam destruídos mesmo
quando nenhum código externo os referencia mais:

```cpp
#include <memory>
#include <iostream>

struct B;
struct A { 
  std::shared_ptr<B> b; 
  ~A() { std::cout << "A destruído\n"; }
};
struct B { 
  std::shared_ptr<A> a; 
  ~B() { std::cout << "B destruído\n"; }
};

int main() {
  auto a = std::make_shared<A>();
  auto b = std::make_shared<B>();
  a->b = b;
  b->a = a; // ciclo criado
  // Nenhum destrutor será chamado - vazamento de memória!
}
```

### weak_ptr

Para resolver o problema de ciclos em shared_ptr, usamos `std::weak_ptr`,
que funciona como um observador que não mantém o objeto vivo. Um weak_ptr
não incrementa o contador de referências, permitindo que o objeto seja
destruído normalmente.

```cpp
#include <memory>
#include <iostream>

struct B;
struct A { 
  std::weak_ptr<B> b; // weak em vez de shared
  ~A() { std::cout << "A destruído\n"; }
};
struct B { 
  std::shared_ptr<A> a; 
  ~B() { std::cout << "B destruído\n"; }
};

int main() {
  auto a = std::make_shared<A>();
  auto b = std::make_shared<B>();
  a->b = b;
  b->a = a; // agora sem ciclo forte
  // Ambos serão destruídos corretamente

  // Para usar o weak_ptr, precisamos converter para shared_ptr
  if (auto locked = a->b.lock()) {
    std::cout << "B ainda existe, pode usar\n";
  } else {
    std::cout << "B já foi destruído\n";
  }
}
```

O método `lock()` tenta converter o weak_ptr em um shared_ptr. Se o
objeto ainda existir, retorna um shared_ptr válido e incrementa o contador
temporariamente. Se o objeto já foi destruído, retorna nullptr. Sempre
verifique o resultado de `lock()` antes de usar.

Use weak_ptr quando precisar observar um objeto gerenciado por shared_ptr
sem afetar sua vida útil, ou quando precisar quebrar ciclos de referência
em estruturas de dados complexas.

## Dicas e comandos úteis

Ao trabalhar com gerenciamento de memória em C++, siga estas diretrizes
práticas.

**Preferência por containers e objetos locais:**
Sempre que possível, use containers da biblioteca padrão como
`std::vector` e `std::string`, ou simplesmente objetos locais na pilha.
Estas opções são seguras, eficientes e eliminam preocupações com
gerenciamento manual.

**Ponteiros crus com cautela:**
Ponteiros crus e referências ainda têm seu lugar, mas devem ser usados
apenas para acesso temporário sem assumir propriedade. Nunca chame `delete`
manualmente em um ponteiro cru quando alternativas modernas estão
disponíveis.

**Compilação com símbolos de debug:**
Para compilar exemplos com informações de debug, útil para ferramentas como
Valgrind:

```bash
g++ -std=c++17 -O0 -g arquivo.cpp -o exec
```

**Detecção de vazamentos com Valgrind:**
Para verificar se seu programa tem vazamentos de memória:

```bash
valgrind --leak-check=full ./exec
```

O relatório indicará vazamentos com mensagens como `definitely lost` ou
`possibly lost`, apontando exatamente onde a memória foi alocada e não
liberada.
